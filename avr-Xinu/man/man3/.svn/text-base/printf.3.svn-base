.TH PRINTF 3
.SH NAME
printf, fprintf, sprintf \- formatted output conversion
.SH SYNOPSIS
.B printf(format
.RB [ ,
arg ] ...
.B )
.br
.B char *format;
.PP
.B fprintf(dev, format
.RB [ ,
arg ] ...
.B )
.br
.B int
.B dev;
.br
.B char *format;
.PP
.B sprintf(s, format
.RB [ ,
arg ] ...
.B )
.br
.B char *s, format;
.SH DESCRIPTION
.I Printf
writes formatted output on device
.IR CONSOLE .
.I Fprintf
writes formatted output on the named output
.IR device .
.I Sprintf
places formatted `output' in the string
.I s,
followed by the character `\\0'.
.PP
Each of these functions 
converts, formats, and prints its arguments after the format
under control of the format argument.
The format argument is a character string
which contains
two types of objects:
plain characters, which are simply copied to the
output stream,
and conversion specifications,
each of which causes conversion and printing
of the next successive
.IR arg .
.PP
Each conversion specification is introduced by
the character
.BR % .
Following the
.BR % ,
there may be, in the following order,
.TP
\-
an optional minus sign `\-' which specifies
.I "left adjustment"
of the converted value
in the
indicated field;
.TP
\-
an optional digit string specifying a
.I "field width;"
if the converted value has fewer characters
than the field width
it will be blank-padded on the left (or right,
if the left-adjustment indicator has been
given) to make up the field width;
if the field width begins with a zero,
zero-padding will be done instead of blank-padding;
.TP
\-
an optional period
.RB ` . '
which serves to
separate the field width from the
next digit string;
.TP
\-
an optional digit string
specifying a
.I precision
which specifies
the maximum number of characters
to be printed from a string;
.TP
\-
the character
.B l
specifying that a following
.BR d ,
.BR o ,
.BR x ,
or
.B u
corresponds to a long integer
.I arg.
(A capitalized conversion code accomplishes
the same thing.)
.TP
\-
a character which indicates the type of
conversion to be applied.
.PP
A field width or precision may be `*' instead of a digit string.
In this case an integer
.I arg
supplies
the field width or precision.
.PP
The conversion characters
and their meanings are
.TP
.B dox
The integer
.I arg
is converted to decimal, octal, or
hexadecimal notation respectively.
.TP
.B c
The character
.I arg
is printed.
Null characters are ignored.
.TP
.B s
.I Arg
is taken to be a string (character pointer)
and characters from the string are printed until
a null character or until
the number of characters indicated by the precision
specification is reached;
however if the precision is 0 or missing
all characters up to a null are printed.
.TP
.B u
The unsigned integer
.I arg
is converted to decimal
and printed (the result will be in the
range 0 through 65535 on the \s-1LSI-11\s0 for normal integers
and 0 through 4294967295 for long integers).
.TP
.B %
Print a `%'; no argument is converted.
.PP
In no case does a non-existent or small field width
cause truncation of a field;
padding takes place only if the specified field
width exceeds the actual width.
Characters generated by
.I printf
are printed by PUTC(2).
.PP
.B Examples
.br
To print a date and time in the form `Sunday, July 3, 10:02',
where
.I weekday
and
.I month
are pointers to null-terminated strings:
.RS
.nh
printf("%s, %s %d, %02d:%02d", weekday, month, day, hour, min);
.RE
.hy
.SH "SEE ALSO"
putc(2), scanf(3)
.SH BUGS
Very wide fields (>128 characters) fail.
